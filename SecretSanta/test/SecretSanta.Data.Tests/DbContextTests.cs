using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.Linq;
using System;
using System.Threading.Tasks;
using System.IO;//cal: both this and Reflection were used to debug our current directory at runtime.
using System.Reflection;
//using DbContext = SecretSanta.Data.DbContext;

namespace SecretSanta.Data.Tests
{
    [TestClass]
    public class DbContextTests
    {

        /*//cal: This is the simple version of the Add gift. It works but doesent cleanup before and after. We're leaving this here for reference if I need it later.
        [TestMethod]
        public void Add_NewGift_Success()
        {
            string workFrom = @"..\..\..\..\..\src\SecretSanta.Data\";//cal: we're using this so that it work with the database in SecretSanta.Data
            Directory.SetCurrentDirectory(workFrom);
            DbContext dbContext = new DbContext();
            int beforeCount = dbContext.Gifts.Count();
            
            //dbContext.Gifts.Add(new Gift(){Title="Colgate " + Guid.NewGuid().ToString(), Url="www." + Guid.NewGuid().ToString() + ".com"});
            
            Gift @gift = new Gift(){Title = "Colgate" +Guid.NewGuid().ToString(), Url="www." + Guid.NewGuid().ToString() + ".com"};
            int id = @gift.Id;
            dbContext.Gifts.Add(@gift);
            dbContext.SaveChanges();

            Assert.AreEqual<int>(beforeCount+1, dbContext.Gifts.Count());

            //cal: below were cleaning up the gift we just added. This works for a simple solution. But Mark showed us a more robust way with the try catches.
            dbContext.Gifts.Remove(@gift);
            dbContext.SaveChanges();
        }
        */

        /*//cal:This was an async version of the simple test. It has possible problems if tests were run concurrently so we stuck with simple.
        [TestMethod]
        async public Task Add_NewGiftAsync_Success()//cal:changed to this since were using SaveChangesAsync() over SaveChanges()
        {
            using DbContext dbContext = new DbContext();//cal: we using "using" here so it cleans up after the method.
            {
                //string path = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
                int beforeCount = dbContext.Gifts.Count();
                
                //dbContext.Gifts.Add(new Gift(){Id=42, Title="Colgate"});//cal: we removed id since if we did, a new one would be autogenerated.
                //dbContext.Gifts.Add(new Gift(){Title="Colgate" + Guid.NewGuid().ToString()});
                
                Gift @gift = new Gift(){Title = "Colgate" +Guid.NewGuid().ToString()};
                int id = @gift.Id;
                dbContext.Gifts.Add(@gift);
                

                Assert.AreEqual<int>(0, @gift.Id);//cal: no db interraction yet till SaveChanges.
                //dbContext.SaveChanges();
                await dbContext.SaveChangesAsync();

                
                Assert.AreEqual<int>(beforeCount+1, dbContext.Gifts.Count());
            }
        }
        */

        [TestMethod]
        public void Add_NewGift_Success()
        {
            Gift @gift;

            string workFrom = @"..\..\..\..\..\src\SecretSanta.Data\";//cal: we're using this so that it work with the database in SecretSanta.Data
            Directory.SetCurrentDirectory(workFrom);
            DbContext dbContext = new DbContext();
            string titlePrefix = $"{nameof(DbContextTests)}.{nameof(Add_NewGift_Success)}";
            void RemoveExistingTestGifts()
            {
                IQueryable<Gift>? giftsToDelete = dbContext.Gifts.Where(item=> item.Title.StartsWith(titlePrefix));
                dbContext.Gifts.RemoveRange(giftsToDelete);
                dbContext.SaveChanges();
            }

            try
            {
                int beforeCount = dbContext.Gifts.Count();
                //cal: were also cleaning up here incase something goes wrong during runtime and didnt clean up previously.
                RemoveExistingTestGifts();
                
                //dbContext.Gifts.Add(new Gift(){Title="Colgate " + Guid.NewGuid().ToString(), Url="www." + Guid.NewGuid().ToString() + ".com"});
                
                @gift = new Gift(){Title = $"{titlePrefix}" +Guid.NewGuid().ToString(), Url="www." + Guid.NewGuid().ToString() + ".com"};
                int id = @gift.Id;
                dbContext.Gifts.Add(@gift);
                dbContext.SaveChanges();

                Assert.AreEqual<int>(beforeCount+1, dbContext.Gifts.Count());
            }
            finally
            {
                //cal: below were cleaning up the gift we just added. This works for a simple solution. But Mark showed us a more robust way with the try catches.
                RemoveExistingTestGifts();
            }
            
        }//end addGiftSs


        [TestMethod]
        public void Add_NewUser_Success()
        {
            User @user;

            string workFrom = @"..\..\..\..\..\src\SecretSanta.Data\";//cal: we're using this so that it work with the database in SecretSanta.Data
            Directory.SetCurrentDirectory(workFrom);
            DbContext dbContext = new DbContext();
            string titlePrefix = $"{nameof(DbContextTests)}.{nameof(Add_NewUser_Success)}";
            void RemoveExistingTestUsers()
            {
                IQueryable<User>? usersToDelete = dbContext.Users.Where(item=> item.FirstName.StartsWith(titlePrefix));
                dbContext.Users.RemoveRange(usersToDelete);
                dbContext.SaveChanges();
            }

            try
            {
                int beforeCount = dbContext.Users.Count();
                //cal: were also cleaning up here incase something goes wrong during runtime and didnt clean up previously.
                RemoveExistingTestUsers();
                
                //dbContext.Users.Add(new User(){Title="Colgate " + Guid.NewGuid().ToString(), Url="www." + Guid.NewGuid().ToString() + ".com"});
                
                @user = new User(){FirstName = $"{titlePrefix}" +Guid.NewGuid().ToString(), LastName= "Ross" + Guid.NewGuid().ToString()};
                int id = @user.Id;
                dbContext.Users.Add(@user);
                dbContext.SaveChanges();

                Assert.AreEqual<int>(beforeCount+1, dbContext.Users.Count());
            }
            finally
            {
                //cal: below were cleaning up the User we just added. This works for a simple solution. But Mark showed us a more robust way with the try catches.
                RemoveExistingTestUsers();
            }
            
        }//end addUserSs

        [TestMethod]
        public void Add_NewGroup_Success()
        {
            Group @group;

            string workFrom = @"..\..\..\..\..\src\SecretSanta.Data\";//cal: we're using this so that it work with the database in SecretSanta.Data
            Directory.SetCurrentDirectory(workFrom);
            DbContext dbContext = new DbContext();
            string titlePrefix = $"{nameof(DbContextTests)}.{nameof(Add_NewGroup_Success)}";
            void RemoveExistingTestGroups()
            {
                IQueryable<Group>? groupsToDelete = dbContext.Groups.Where(item=> item.Name.StartsWith(titlePrefix));
                dbContext.Groups.RemoveRange(groupsToDelete);
                dbContext.SaveChanges();
            }

            try
            {
                int beforeCount = dbContext.Groups.Count();
                //cal: were also cleaning up here incase something goes wrong during runtime and didnt clean up previously.
                RemoveExistingTestGroups();
                
                //dbContext.Groups.Add(new Group(){Title="Colgate " + Guid.NewGuid().ToString(), Url="www." + Guid.NewGuid().ToString() + ".com"});
                
                @group = new Group(){Name = $"{titlePrefix}" +Guid.NewGuid().ToString()};
                int id = @group.Id;
                dbContext.Groups.Add(@group);
                dbContext.SaveChanges();

                Assert.AreEqual<int>(beforeCount+1, dbContext.Groups.Count());
            }
            finally
            {
                //cal: below were cleaning up the Group we just added. This works for a simple solution. But Mark showed us a more robust way with the try catches.
                RemoveExistingTestGroups();
            }
            
        }

    }//end Test class
}
